import "VxWorksComponentC.stg"
import "Common.stg"
import "CommonCPrototypes.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to eChronos .prx file
//
////////////////////////////////////////////////////////////////////////////

filePurpose(sysInstanceName) ::= <<
This file contains the declarations required for the cross-component
RPC calls for VxWorks.
>>

headerIfdef(sysInstanceName) ::= "__SMACCM_<sysInstanceName>_decls__H"

filePrefix(name, date, path) ::= <<
#ifndef <headerIfdef(name)>
#define <headerIfdef(name)>

<DARPALicenseComment()>

<filenameBlockComment(date, path, filePurpose(name))>

>>

filePostfix(name, path) ::= <<

/* endif for: #ifndef <headerIfdef(name)> */
#endif

<blockComment(arg={End of autogenerated file: <path>})>

>>

/*
dataWriterDecl(port) ::= <<
bool <incomingPortWriterName(port)>(<port.type.camkesInputType.name> arg);
>>
*/

writerDecl(port) ::= <<
<if(port.isIRQ)>
<else>
bool <incomingPortWriterName(port)><if(port.hasData)>(const <port.type.camkesInputType.name> arg);<else>();<endif>
<endif>
>>

/*
 * In CAmkES, we write to the output port.
 * In eChronos and VxWorks, we should write to the input port.
 * So, we only want the input ports.  We don't
 * even want the dispatchers.  However, for event
 * and event data ports, we need to know whether
 * the thread is active or passive so that we know
 * what can subsequently dispatch.
 */

activeThreadDecls(threadImpl) ::= <<
// task id for the thread
extern int <threadImpl.normalizedName>;
<osSpecificThreadEntrypoint(threadImpl)>;
<threadImpl.inputPortList:writerDecl()>
>>

passiveThreadDecls(threadImpl) ::= <<
<threadImpl.dispatchers:userEntrypointCallerDecl()>
>>


writeActiveThreadMutexes(threadImpl, extern) ::= <<
/* dispatcher, input port, and external mutexes for active thread <threadImpl.normalizedName> */
<extern> SEM_ID <threadImpl.threadDispatcherMutex>;
<threadImpl.inputPortList:{port | <extern> SEM_ID <port.mutex>;
}>
<threadImpl.externalMutexes:{ m | <extern> SEM_ID <m>;
}>
>>

writePassiveThreadMutexes(threadImpl, extern) ::= <<
/* dispatcher and external mutex for passive thread (monitor) <threadImpl.normalizedName> */
<extern> SEM_ID <threadImpl.threadDispatcherMutex>;
<threadImpl.externalMutexes:{ m | <extern> SEM_ID <m>;
}>
>>

writeModelMutexes(model, extern) ::= <<
/* model-level external mutexes */
<model.externalMutexList:{ m | <extern> SEM_ID <m>;
}>
>>

writeMutexes(model, extern) ::= <<
<writeModelMutexes(model, extern)>
<model.activeThreadImplementations:writeActiveThreadMutexes(extern)>
<model.passiveThreadImplementations:writePassiveThreadMutexes(extern)>
>>


headerBody(model) ::= <<

#include \<../usr/h/stdbool.h>
#include \<stddef.h>
#include \<../usr/h/stdint.h>
#include \<semLib.h>
#include \<taskLib.h>
#include <\u0022><model.systemTypeHeaderName><\u0022>

// to initialize periodic dispatcher.  Call from main() before
// starting OS.

bool initialize_periodic_dispatcher();
int trusted_build_main(uint32_t runDurationInSeconds);
   <model.activeThreadImplementations:activeThreadDecls()>
   <model.passiveThreadImplementations:passiveThreadDecls()>

   <writeMutexes(model, "extern")>
>>
