delimiters "$", "$"
import "xmlCommon.stg"

//imported from eChronosComponentC
incomingPortWriterName(port) ::= "smaccm_$port.qualifiedName$_$port.type.writerFn$"
incomingActiveThreadDispatchName(dispatcher) ::= "$incomingPortWriterName(dispatcher)$"


////////////////////////////////////////////////////////////////////////////
//
// Declarations related to eChronos .prx file
//
////////////////////////////////////////////////////////////////////////////

prxPurpose(sysInstanceName) ::= <<
This file contains the main eChronos .prx assembly for the
AADL system instance rooted at $sysInstanceName$.
>>

filePrefix(name, date, path, datatypesHeader) ::= <<
<?xml version="1.0" encoding="UTF-8" ?>
$xmlDARPALicenseComment()$

$xmlFilenameBlockComment(date, path, prxPurpose(name))$

>>

filePostfix(name, path) ::= <<

$xmlBlockComment(arg={End of autogenerated file: $path$})$

>>

writeTrampoline(name, flihName) ::= <<

    <trampoline>
        <name>$name$</name>
        <handler>$flihName$</handler>
    </trampoline>

>>

writeDispatcherTrampoline(dispatcher) ::= <<
$writeTrampoline(dispatcher.signalName, incomingActiveThreadDispatchName(dispatcher))$
>>

writeExternalIsrTrampoline(externalIsr) ::= <<
$writeTrampoline(externalIsr.name, externalIsr.handlerName)$
>>

writeTrampolines(model) ::= <<
$model.irqDispatchers:writeDispatcherTrampoline()$
$if(model.threadCalendar.hasDispatchers &&
    model.generateSystickIrq)$
$writeTrampoline("systick", "smaccm_tick_irq")$
$endif$
$model.externalISRs:writeExternalIsrTrampoline()$
>>

writeInternalInterruptHandler(signalName) ::= <<
<$signalName$>exception_preempt_trampoline_$signalName$</$signalName$>
>>

writeExternalInterruptHandler(signalName, signalNumber) ::= <<
<external_irq>
    <number>$signalNumber$</number>
    <handler>exception_preempt_trampoline_$signalName$</handler>
</external_irq>
>>

writeInternalDispatcherInterruptHandler(dispatcher) ::= <<
$writeInternalInterruptHandler(dispatcher.signalName)$
>>

writeExternalDispatcherInterruptHandler(dispatcher) ::= <<
$writeExternalInterruptHandler(dispatcher.signalName, dispatcher.signalNumber)$
>>

writeInterruptHandlers(model) ::= <<
$if(model.threadCalendar.hasDispatchers &&
    model.generateSystickIrq)$
$writeInternalInterruptHandler("systick")$
$endif$
$model.internalIrqDispatchers:writeInternalDispatcherInterruptHandler()$
<external_irqs>
    $model.externalIrqDispatchers:writeExternalDispatcherInterruptHandler()$
</external_irqs>
>>

writeSignalLabels(model) ::= << >>

writeTask(threadImpl) ::= <<
    <task>
        <name>$threadImpl.normalizedName$</name>
        <function>$threadImpl.threadImplMainFnName$</function>
        <priority>$threadImpl.priority$</priority>
        <stack_size>$threadImpl.osSpecificStackSize$</stack_size>
    </task>
>>

writeTasks(model) ::= <<
$model.ActiveThreadImplementations:writeTask()$
>>

/*
 * $if(model.threadCalendar.hasDispatchers)$
    <!-- NOTE: the threadCalendar priority is currently hard-coded.  We should add a user property -->
    <task>
        <name>smaccm_periodic_dispatcher</name>
        <function>smaccm_periodic_dispatcher</function>
        <priority>$model.threadCalendar.priority$</priority>
        <stack_size>512</stack_size>
    </task>
$else$
    <!-- No periodic dispatcher thread -->
$endif$

 */
writeMutex(name) ::= <<
  <mutex>
    <name>$name$</name>
  </mutex>
>>

// Fill in more stuff HERE!
writeInputPortMutex(port) ::= <<
$writeMutex(port.mutex)$
>>

writeActiveThreadMutexes(threadImpl) ::= <<
$writeMutex(threadImpl.threadDispatcherMutex)$
$threadImpl.inputPortList:writeInputPortMutex()$
$threadImpl.externalMutexes:writeMutex()$
>>

writePassiveThreadMutexes(threadImpl) ::= <<
$writeMutex(threadImpl.threadDispatcherMutex)$
$threadImpl.externalMutexes:writeMutex()$
>>

writeMutexes(model) ::= <<
$model.externalMutexList:writeMutex()$
$model.activeThreadImplementations:writeActiveThreadMutexes()$
$model.passiveThreadImplementations:writePassiveThreadMutexes()$
>>

writeSemaphore(name) ::= <<
  <semaphore>
    <name>$name$</name>
  </semaphore>
>>

writeThreadSemaphores(threadImpl) ::= <<
$threadImpl.externalSemaphores:writeSemaphore()$
>>

writeSemaphores(model) ::= <<
    $model.externalSemaphoreList:writeSemaphore()$
    $model.threadImplementations:writeThreadSemaphores()$
>>


writeInterruptEvent(name, taskName, signalSet) ::= <<
<interrupt_event>
    <name>$name$</name>
    <task>$taskName$</task>
    <sig_set>$signalSet$</sig_set>
</interrupt_event>
>>

writeExternalIrqEvent(externalIrqEvent) ::= <<
$writeInterruptEvent(
    externalIrqEvent.name,
    externalIrqEvent.taskName,
    externalIrqEvent.signalSet)$
>>

/*
writeActiveThreadIrqDispatcher(dispatcher) ::= <<
$if(dispatcher.isIRQ)$
$writeInterruptEvent(dispatcher.name, dispatcher.threadImplementation.normalizedName, "smaccm_dispatcher")$
$elseif(dispatcher.isPeriodic)$
$writeInterruptEvent(dispatcher.threadImplementation.eChronosInterruptSignal, dispatcher.threadImplementation.normalizedName, "smaccm_dispatcher")$
$endif$
>>


 $threadImpl.dispatchers:writeActiveThreadIrqDispatcher()$
 *
 */



writeActiveThreadIrqDispatchers(threadImpl) ::= <<
$writeInterruptEvent(threadImpl.eChronosInterruptSignal, threadImpl.normalizedName, threadImpl.eChronosDispatchSignal)$
>>

writeInterruptEvents(model) ::= <<
    $model.externalIRQEvents:writeExternalIrqEvent()$
    $model.activeThreadImplementations:writeActiveThreadIrqDispatchers()$
>>

writeCodeModule(moduleName, model) ::= <<
<module name="$model.eChronosCModulePath$.$moduleName$" />
>>

writeCodeModules(model) ::= <<
$model.cFileModules:writeCodeModule(model)$
>>
